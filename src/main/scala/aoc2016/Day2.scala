package aoc2016

import scala.util.Try

object Day2 extends App {

  trait Dir
  case object U extends Dir
  case object D extends Dir
  case object L extends Dir
  case object R extends Dir

  def parseDir(c: Char) = c match {
    case 'U' => U
    case 'D' => D
    case 'L' => L
    case 'R' => R
    case x => throw new IllegalArgumentException(s"Unexpected [$x]")
  }

  val input =
    """DLUUULUDLRDDLLLUDULLULLRUURURLUULDUUUDLDDRUDLUULLRLDDURURDDRDRDLDURRURDLDUURULDDULDRDDLDLDLRDRUURLDLUDDDURULRLLLLRLULLUDRDLDUURDURULULULRLULLLULURLRDRDDDDDDDLRLULUULLULURLLDLRLUDULLDLLURUDDLDULDLULDDRLRLRDDLRURLLLURRLDURRDLLUUUUDRURUULRLDRRULLRUDLDRLUDRDRDRRDDURURRDRDRUDURDLUDRUDLRRULDLRDDRURDDUUDLDRDULDDRRURLLULRDRURLRLDLLLUULUUDLUDLDRRRRDUURULDUDUDRLDLLULLLRDDDDDLRDDLLUULLRRRDURLRURDURURLUDRRLRURDRDRRRRULUDLDRDULULRUDULLLUDRRLRLURDDURULDUUDULLURUULRDRDULRUUUDURURDDRRUDURRLRDRULRUUU
      |LDRURRUUUULDRDDDLLULDRUDDRLLDLDRDLRUDDDLDDULULULLRULDUDRRDLRUURURDRURURDLLRUURDUUDRLDURDRDLRRURURDUUUURUURRLLLDRDUURRRRURULUUUDLUDDRUURRLDULRDULRRRRUDURRLURULRURRDRDLLDRRDUDRDURLDDRURULDRURUDDURDLLLUURRLDRULLURDRDRLDRRURRLRRRDDDDLUDLUDLLDURDURRDUDDLUDLRULRRRDRDDLUDRDURDRDDUURDULRRULDLDLLUDRDDUDUULUDURDRLDURLRRDLDDLURUDRLDUURLLRLUDLLRLDDUDLLLRRRLDLUULLUDRUUDRLDUUUDUURLRDDDDRRDRLDDRDLUDRULDDDRDUULLUUUUULDULRLLLRLLDULRDUDDRDDLRRLRDDULLDURRRURDDUDUDDRLURRLUUUULLDRDULUUDRDULDLLUDLURDLLURRDLUULURRULRLURRRRRUURDDURLRLLDDLRRDUUURDRDUDRDDDLLDDRDRRRLURRDUULULULULRRURDDLDDLLLRUDDDDDDLLLRDULURULLRLRDRR
      |DDRLLLDLRRURRDLDDRUURRURRLRRRRUURUURDLURRRDDLRUDRURLUURLLRRLRLURLURURDULLLLDLRURULUUDURRLULRDRDRRDDLLULRLUDLUUUDRLLRRURRLDULDDLRRLUUUUDDLRLDRLRRDRDLDDURDDRDDLDLURLRRRDDUDLLRLRLURRRRULLULLLLDRLDULDLLDULRLDRDLDDRRDDDDRUDRLLURULRLDDLLRRURURDDRLLLULLULDDRDLDDDLRLLDRLDRUURRULURDDRLULLDUURRULURUUDULLRUDDRRLLDLLRDRUDDDDLLLDDDLLUUUULLDUUURULRUUDUUUDDLDURLDRDRRLLUDULDLUDRLLLDRRRULUUDDURUDRLUDDRRLLDUDUURDDRURLUURDURURURRUUDUDDLLLDRRRURURRURDLRULLDUDRLRLLRUDRUDLR
      |RRRDRLRURLRRLUURDRLDUURURLRDRRUDLLUUDURULLUURDLLDRRLURRUDUUDRRURLRRDULLDDLRRRUDUUDUUDLDDDLUUDLDULDDULLDUUUUDDUUDUDULLDDURRDLRRUDUDLRDUULDULRURRRLDLLURUDLDDDRRLRDURDLRRLLLRUDLUDRLLLRLLRRURUDLUDURLDRLRUDLRUULDRULLRLDRDRRLDDDURRRUDDDUDRRDRLDDRDRLLRLLRDLRDUDURURRLLULRDRLRDDRUULRDDRLULDLULURDLRUDRRDDDLDULULRDDRUDRLRDDRLDRDDRRRDUURDRLLDDUULRLLLULLDRDUDRRLUUURLDULUUURULLRLUDLDDLRRDLLRDDLRDRUUDURDDLLLDUUULUUDLULDUDULDRLRUDDURLDDRRRDLURRLLRRRUDDLDDRURDUULRUURDRRURURRRUUDUDULUDLUDLLLUUUULRLLRRRRDUDRRDRUDURLUDDLDRDLDDRULLRRULDURUL
      |DLLLRDDURDULRRLULURRDULDLUDLURDDURRLLRRLLULRDLDRDULRLLRDRUUULURRRLLRLDDDRDRRULDRRLLLLDLUULRRRURDDRULLULDDDLULRLRRRUDRURULUDDRULDUDRLDRRLURULRUULLLRUURDURLLULUURUULUUDLUDLRRULLLRRLRURDRRURDRULRURRUDUDDDRDDULDLURUDRDURLDLDLUDURLLRUULLURLDDDURDULRLUUUDLLRRLLUURRDUUDUUDUURURDRRRRRRRRRUDULDLULURUDUURDDULDUDDRDDRDRLRUUUUDLDLRDUURRLRUUDDDDURLRRULURDUUDLUUDUUURUUDRURDRDDDDULRLLRURLRLRDDLRUULLULULRRURURDDUULRDRRDRDLRDRRLDUDDULLDRUDDRRRD""".stripMargin

  //  val input =
  //    """ULL
  //      |RRDDD
  //      |LURDL
  //      |UUUUD""".stripMargin

  val parsed: Seq[Seq[Dir]] = input.lines.toList.map(line => line.map(parseDir))

  parsed.foreach(println)


  object Part1 {

    val keypad = Seq(
      Seq(1, 2, 3),
      Seq(4, 5, 6),
      Seq(7, 8, 9))


    case class Pos(r: Int, c: Int) {
      require(r >= 0 && c >= 0)
      require(r < 3 && c < 3)
      def move(d: Dir): Pos = d match {
        case U => Try(this.copy(r = r - 1)).getOrElse(this)
        case D => Try(this.copy(r = r + 1)).getOrElse(this)
        case L => Try(this.copy(c = c - 1)).getOrElse(this)
        case R => Try(this.copy(c = c + 1)).getOrElse(this)
      }

      def move(ds: Seq[Dir]): Pos = ds.foldLeft(this) { (p, d) => p.move(d) }
    }


    val code = parsed.foldLeft(Seq(Pos(1, 1))) { (ps, ds) => ps :+ ps.last.move(ds) }
      .map(p => keypad(p.r)(p.c))
      .drop(1)

  }
  println(Part1.code.mkString)

  object Part2 {

    val keypad = Seq(
      Seq(' ', ' ', '1', ' ', ' '),
      Seq(' ', '2', '3', '4', ' '),
      Seq('5', '6', '7', '8', '9'),
      Seq(' ', 'A', 'B', 'C', ' '),
      Seq(' ', ' ', 'D', ' ', ' '))


    case class Pos(r: Int, c: Int) {
      require(r >= 0 && c >= 0)
      require(r < 5 && c < 5)
      require(keypad(r)(c) != ' ')
      def move(d: Dir): Pos = d match {
        case U => Try(this.copy(r = r - 1)).getOrElse(this)
        case D => Try(this.copy(r = r + 1)).getOrElse(this)
        case L => Try(this.copy(c = c - 1)).getOrElse(this)
        case R => Try(this.copy(c = c + 1)).getOrElse(this)
      }

      def move(ds: Seq[Dir]): Pos = ds.foldLeft(this) { (p, d) => p.move(d) }
    }


    val code = parsed.foldLeft(Seq(Pos(2, 0))) { (ps, ds) => ps :+ ps.last.move(ds) }
      .map(p => keypad(p.r)(p.c))
      .drop(1)

  }
  println(Part2.code.mkString)
}
